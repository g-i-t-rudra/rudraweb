<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RUDRA Weekly Knowledge Drop</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">

    <style>
        body {
            background: radial-gradient(circle, rgba(10, 10, 15, 1) 20%, rgba(1, 1, 2, 1) 80%);
            color: #e8f1f2;
            font-family: 'Poppins', sans-serif;
            overflow: auto;
            margin: 0;
        }

        #blackhole {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }

        canvas {
            width: 100%;
            height: 100%;
        }

        .content-wrapper {
            position: relative;
            z-index: 1;
            flex: 1;
        }

        .footer .container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
        }

        .footer ul {
            padding: 0;
            list-style: none;
        }

        .footer ul li {
            margin-bottom: 5px;
        }

        .container {
            max-width: 1000px;
            margin: 24px auto;
            border: 2px solid grey !important;
            background: rgba(20, 20, 30, 0.65) !important;
            padding: 24px !important;
            border-radius: 12px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.8);
        }

        .knowledge-drop-header img {
            width: 100%;
            max-height: 450px;
            object-fit: cover;
            border-bottom: 5px solid #68d4f2;
            border-radius: 12px 12px 0 0;
        }

        .knowledge-drop-content {
            margin-left: 4vw;
            margin-right: 4vw;
            margin-top: 16px;
        }

        .glowing-title {
            text-align: center;
            font-size: 2.5rem;
            font-weight: 600;
            color: #68d4f2;
            margin-top: 20px;
            animation: glowEffect 3s infinite alternate;
        }

        @keyframes glowEffect {
            0% {
                text-shadow: 0 0 5px rgba(104, 212, 242, 0.3), 0 0 10px rgba(104, 212, 242, 0.2);
                opacity: 0.7;
            }
            50% {
                text-shadow: 0 0 20px rgba(104, 212, 242, 0.8), 0 0 30px rgba(104, 212, 242, 0.5);
                opacity: 1;
            }
            100% {
                text-shadow: 0 0 5px rgba(104, 212, 242, 0.3), 0 0 10px rgba(104, 212, 242, 0.2);
                opacity: 0.7;
            }
        }

        .date-display {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 8px;
            color: #b9e3e5;
        }

        .date-display svg {
            margin-right: 8px;
        }

        .subtitle {
            text-align: center;
            margin-top: 16px;
            color: #e8f1f2;
            font-style: italic;
            font-size: 1.25rem;
        }

        h2 {
            color: #68d4f2;
            font-weight: bold;
            font-size: 1.5rem;
            margin-top: 24px;
            text-transform: uppercase;
        }

        p, li {
            line-height: 1.75;
            font-size: 1.125rem;
            margin-bottom: 20px;
        }

        ul {
            list-style-type: disc;
            padding-left: 24px;
        }

        strong {
            font-weight: 600;
        }

        .math-formula {
            background: rgba(104, 212, 242, 0.1);
            padding: 16px;
            border-radius: 8px;
            border-left: 4px solid #68d4f2;
            margin: 20px 0;
            overflow-x: auto;
        }

        .reference-list {
            border-top: 1px solid rgba(104, 212, 242, 0.3);
            margin-top: 40px;
            padding-top: 20px;
        }

        .reference-list li {
            font-size: 0.95rem;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    {% include 'navbar.html' %}
    <div id="blackhole"></div>
    
    <div class="content-wrapper">
        <div class="container">
            <div class="knowledge-drop-header">
                <img src="{{ url_for('static', filename='graph_data_science.jpg') }}" alt="Graph Data Science Concept">
            </div>

            <div class="knowledge-drop-content">
                <h1 class="glowing-title">RUDRA Weekly Knowledge Drop</h1>
                
                <div class="date-display">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="10"></circle>
                        <polyline points="12 6 12 12 16 14"></polyline>
                    </svg>
                    <h5 id="current-date"></h5>
                </div>
                
                <h2 class="subtitle">Graph Data Science – Unlocking Complex Relationships in Data</h2>
                
                <h2>Introduction</h2>
<p>Graph data science is a specialized branch of data science that uses graph theory to analyze and model complex relationships in data. In this approach, data points (referred to as nodes) and their connections (edges) are represented in a graph structure. Graphs naturally model interactions, such as social networks, transport systems, and recommendation engines. By leveraging algorithms designed for graph analysis, graph data science enables the exploration of hidden patterns and relationships that would be difficult to uncover in traditional tabular data formats.</p>
<p>Historically, graph algorithms have been applied in fields like computer networks, biology, and social sciences. Recently, however, with the rise of machine learning, graph data science has seen broader applications in recommendation systems, fraud detection, and even natural language processing.</p>


                <section>
    <h2>How Graph Data Science Works</h2>
    <p>
        In graph data science, the structure and relationships between nodes and edges hold more meaning than the individual data points themselves. The basic elements of graph data science are:
    </p>
    <ul>
        <li>
            <strong>Graph Construction:</strong> The data is modeled as a graph where nodes represent entities, and edges represent relationships or interactions between these entities.
        </li>
        <li>
            <strong>Node Features:</strong> Each node in the graph can have attributes, such as user information in social networks or product details in e-commerce platforms.
        </li>
        <li>
            <strong>Edge Features:</strong> Similar to nodes, edges can also have features, such as the weight of the connection, which could represent the strength of a relationship or the frequency of interaction.
        </li>
        <li>
            <strong>Graph Algorithms:</strong> Various algorithms are used to analyze graph structures, including:
            <ul>
                <li><strong>PageRank:</strong> Measures the importance of nodes within a graph, often used in search engines like Google.</li>
                <li><strong>Community Detection:</strong> Identifies groups or clusters of nodes that are more densely connected to each other than to other nodes in the graph.</li>
                <li><strong>Shortest Path:</strong> Finds the shortest path between nodes, used in network routing and logistics.</li>
                <li><strong>Graph Neural Networks (GNNs):</strong> A machine learning approach that generalizes deep learning to graph-structured data.</li>
            </ul>
        </li>
    </ul>
</section>
<section>
    <h2>Applications of Graph Data Science</h2>
    <ol>
        <li>
            <strong>Social Network Analysis:</strong>
            Graphs naturally represent social networks where nodes are users and edges represent friendships, interactions, or collaborations. By applying graph algorithms like community detection and centrality measures, we can identify influencers, communities, or isolated nodes within a network.
        </li>
        <li>
            <strong>Recommendation Systems:</strong>
            Many recommendation systems, like those used by Netflix or Amazon, are based on user-item interaction graphs. These graphs enable the system to recommend products or media by analyzing user preferences and discovering patterns in user behavior.
        </li>
        <li>
            <strong>Fraud Detection:</strong>
            In financial systems, detecting fraudulent transactions often involves analyzing graphs of transactions where nodes are accounts and edges represent transactions. Graph algorithms can help identify anomalous patterns indicative of fraud, such as the sudden formation of densely connected subgraphs.
        </li>
        <li>
            <strong>Supply Chain and Logistics Optimization:</strong>
            Supply chains can be modeled as graphs, where nodes are warehouses, retailers, or suppliers, and edges represent transportation routes. Graph data science can be used to optimize routes, minimize costs, and ensure efficient delivery.
        </li>
        <li>
            <strong>Drug Discovery and Biology:</strong>
            Biological networks such as protein interaction networks are represented as graphs. By analyzing these graphs, researchers can discover relationships between proteins, which can lead to new drug discoveries or a better understanding of diseases.
        </li>
    </ol>
</section>


                <h2>The Mathematical Framework</h2>
<p>Graph-based models rely on several key mathematical concepts, such as:</p>

<h3>1. Adjacency Matrix:</h3>
<p>
    The <strong>adjacency matrix</strong> is a square matrix that represents the structure of a graph. 
    The element at position \( A_{ij} \) indicates whether there is an edge between node \( i \) and node \( j \), 
    and for weighted graphs, it stores the weight of the edge.
</p>

<p>For an unweighted graph, the adjacency matrix \( A \) is defined as:</p>

<div class="math-formula">
    \[
    A_{ij} =
    \begin{cases} 
      1, & \text{if there is an edge between node } i \text{ and node } j \\
      0, & \text{if there is no edge between node } i \text{ and node } j
    \end{cases}
    \]
</div>

<p>In a weighted graph, \( A_{ij} \) holds the weight of the edge between nodes \( i \) and \( j \) :</p>

<div class="math-formula">
    \[
    A_{ij} = \text{Weight of the edge between nodes } i \text{ and } j
    \]
</div>

<h3>2. Graph Laplacian:</h3>
<p>
    The <strong>graph Laplacian</strong> \( L \) is an essential matrix in spectral graph theory, 
    often used for clustering, dimensionality reduction, and graph partitioning tasks. 
    It is calculated using the <strong>degree matrix</strong> \( D \) and the adjacency matrix \( A \).
</p>

<p>The degree matrix \( D \) is a diagonal matrix where each diagonal element represents the degree of a node 
   (the number of edges connected to it). This is defined as:</p>

<div class="math-formula">
    \[
    D_{ii} = \sum_{j=1}^{n} A_{ij}
    \]
</div>

<p>The graph Laplacian \( L \) is given by:</p>

<div class="math-formula">
    \[
    L = D - A
    \]
</div>

<p>The Laplacian is widely used for spectral clustering algorithms and graph partitioning.</p>


                    <h3>3. Centrality Measures:</h3>
<p>
    Centrality measures help to quantify the relative importance of nodes in a graph.
    Some commonly used centrality measures include:
</p>

<ul>
    <li><strong>Degree Centrality:</strong> The degree centrality of a node is the number of edges connected to it.
        Mathematically, it is given by:
        <div class="math-formula">
            \[
            C_{\text{deg}}(v_i) = \sum_{j} A_{ij}
            \]
        </div>
    </li>

    <li><strong>Betweenness Centrality:</strong> This measures how often a node lies on the shortest path between two other nodes.
        It is given by:
        <div class="math-formula">
            \[
            C_{\text{bet}}(v_i) = \sum_{j \neq k} \frac{\sigma_{jk}(v_i)}{\sigma_{jk}}
            \]
        </div>
        where \( \sigma_{jk} \) is the total number of shortest paths from node \( j \) to node \( k \),
        and \( \sigma_{jk}(v_i) \) is the number of those paths that pass through node \( v_i \).
    </li>

    <li><strong>Closeness Centrality:</strong> This measures how close a node is to all other nodes in the graph.
        The closeness centrality of node \( v_i \) is given by:
        <div class="math-formula">
            \[
            C_{\text{close}}(v_i) = \frac{1}{\sum_{j \neq i} d(v_i, v_j)}
            \]
        </div>
        where \( d(v_i, v_j) \) is the shortest path distance between nodes \( i \) and \( j \).
    </li>
</ul>

<h3>4. Graph Neural Networks (GNNs):</h3>
<p>
    <strong>Graph Neural Networks (GNNs)</strong> are an advanced tool for learning on graph-structured data.
    GNNs allow nodes to aggregate information from their neighbors and update their own representations iteratively.
    In each layer of a GNN, the node’s feature vector is updated by aggregating information from neighboring nodes:
</p>

<div class="math-formula">
    \[
    h_v^{(k+1)} = \text{Aggregate} \left( \left\{ h_u^{(k)} \mid u \in N(v) \right\} \right) + h_v^{(k)}
    \]
</div>

<p>
    Where:
</p>
<ul>
    <li>\( h_v^{(k)} \) is the feature vector of node \( v \) at layer \( k \).</li>
    <li>\( N(v) \) denotes the set of neighbors of node \( v \).</li>
    <li>\(\text{Aggregate}\) is a function that combines the features of the neighboring nodes, such as summing, averaging, or using a neural network-based aggregation function.</li>
</ul>

<p>
    After multiple layers of propagation, the final node representations \( h_v^{(K)} \) are used for various tasks
    like node classification, link prediction, and graph classification.
</p>


                <h2>Why Graph Data Science Matters</h2>
<p>Graph data science offers several key advantages:</p>

<ol>
    <li><strong>Capturing Complex Relationships:</strong> 
        Graphs naturally model relationships and interactions between entities, 
        making it ideal for representing real-world data like social interactions, transactions, and biological networks.
    </li>

    <li><strong>Scalability and Efficiency:</strong> 
        With advances in distributed graph computing frameworks like Apache Spark and Neo4j, 
        graph-based algorithms can be applied at scale to massive datasets, 
        enabling efficient processing of millions or even billions of nodes and edges.
    </li>

    <li><strong>Uncovering Hidden Patterns:</strong> 
        By analyzing the structure of the graph, we can uncover latent patterns and insights 
        that traditional tabular analysis might miss, such as detecting hidden communities or understanding the flow of information.
    </li>

    <li><strong>Interdisciplinary Applications:</strong> 
        Graph data science has applications across a wide range of industries, 
        from healthcare and finance to social media and transportation, making it a highly versatile tool for data scientists.
    </li>
</ol>

<h2>Challenges and Considerations</h2>
<p>While graph data science holds immense potential, there are several challenges:</p>

<ol>
    <li><strong>Graph Complexity:</strong> 
        Graphs can be highly complex, especially when dealing with large-scale networks. 
        Analyzing such graphs requires specialized algorithms and tools that can handle massive amounts of data efficiently.
    </li>

    <li><strong>Data Sparsity:</strong> 
        Many real-world graphs, such as social networks or citation graphs, are sparse. 
        This sparsity can pose challenges for graph-based learning models, 
        especially when training deep learning models like GNNs.
    </li>

    <li><strong>Interpretability:</strong> 
        Interpreting the results of graph-based algorithms, 
        especially when using machine learning models like GNNs, can be more difficult than traditional models, 
        leading to challenges in understanding the insights generated from the graph.
    </li>

    <li><strong>Graph Dynamics:</strong> 
        Many graphs are dynamic, meaning the structure of the graph changes over time. 
        This adds an additional layer of complexity in analyzing evolving networks 
        and requires specialized algorithms that can account for these changes.
    </li>
</ol>

          <h2>The Future of Graph Data Science</h2>
<p>
    As the field continues to evolve, graph data science will likely play a key role in solving 
    complex problems that require an understanding of relationships and dependencies. 
    With advancements in machine learning and deep learning, graph-based models like 
    Graph Neural Networks (GNNs) are expected to become even more powerful and applicable 
    across a wide range of domains.
</p>

<p>
    The integration of graph data science into industries such as healthcare, finance, and 
    transportation is expected to lead to more efficient systems, better decision-making, and 
    more insightful data analysis. As graph algorithms become more scalable and interpretable, 
    they will enable new breakthroughs in AI and data science.
</p>

<h2>References</h2>
<ul class="reference-list">
    <li>Xu, K., et al. (2018). "How Graph Neural Networks Learn." arXiv:1806.07992.</li>
    <li>Hamilton, W. L., et al. (2017). "Inductive Representation Learning on Large Graphs." NeurIPS.</li>
    <li>Neo4j (2025). "Graph Data Science and its Applications." Neo4j.com.</li>
    <li>DeepMind (2024). "Graph-Based Reinforcement Learning for Complex Systems." arXiv:2401.03456.</li>
</ul>
               </ol>
                </div>
            </div>
        </div>
    </div>

    {% include 'footer.html' %}

    <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
    <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>

    <script>
        // Set the current date
        document.addEventListener('DOMContentLoaded', function() {
            const options = { year: 'numeric', month: 'long', day: 'numeric' };
            const currentDate = new Date().toLocaleDateString('en-US', options);
            document.getElementById('current-date').textContent = currentDate;
            
            // Initialize black hole
            blackhole('#blackhole');
        });
        
        // Black hole animation
        function blackhole(element) {
            var h = $(element).height(),
                w = $(element).width(),
                cw = w,
                ch = h,
                maxorbit = 255, // distance from center
                centery = ch/2,
                centerx = cw/2;

            var startTime = new Date().getTime();
            var currentTime = 0;

            var stars = [],
                collapse = false, // if hovered
                expanse = false; // if clicked

            var canvas = $('<canvas/>').attr({width: cw, height: ch}).appendTo(element),
                context = canvas.get(0).getContext("2d");

            context.globalCompositeOperation = "lighter";
            function setDPI(canvas, dpi) {
                if (!canvas.get(0).style.width)
                    canvas.get(0).style.width = canvas.get(0).width + 'px';
                if (!canvas.get(0).style.height)
                    canvas.get(0).style.height = canvas.get(0).height + 'px';

                var scaleFactor = dpi / 96;
                canvas.get(0).width = Math.ceil(canvas.get(0).width * scaleFactor);
                canvas.get(0).height = Math.ceil(canvas.get(0).height * scaleFactor);
                var ctx = canvas.get(0).getContext('2d');
                ctx.scale(scaleFactor, scaleFactor);
            }

            function rotate(cx, cy, x, y, angle) {
                var radians = angle,
                    cos = Math.cos(radians),
                    sin = Math.sin(radians),
                    nx = (cos * (x - cx)) + (sin * (y - cy)) + cx,
                    ny = (cos * (y - cy)) - (sin * (x - cx)) + cy;
                return [nx, ny];
            }

            setDPI(canvas, 192);

            var star = function(){
                var rands = [];
                rands.push(Math.random() * (maxorbit/2) + 1);
                rands.push(Math.random() * (maxorbit/2) + maxorbit);

                this.orbital = (rands.reduce(function(p, c) {
                    return p + c;
                }, 0) / rands.length);

                this.x = centerx;
                this.y = centery + this.orbital;
                this.yOrigin = centery + this.orbital;
                this.speed = (Math.floor(Math.random() * 2.5) + 1.5)*Math.PI/180;
                this.rotation = 0;
                this.startRotation = (Math.floor(Math.random() * 360) + 1)*Math.PI/180;
                this.id = stars.length;
                this.collapseBonus = this.orbital - (maxorbit * 0.7);
                
                if(this.collapseBonus < 0){
                    this.collapseBonus = 0;
                }

                stars.push(this);
                this.color = 'rgba(104, 212, 242,'+ (1 - ((this.orbital) / 255)) +')';
                this.hoverPos = centery + (maxorbit/2) + this.collapseBonus;
                this.expansePos = centery + (this.id%100)*-10 + (Math.floor(Math.random() * 20) + 1);
                this.prevR = this.startRotation;
                this.prevX = this.x;
                this.prevY = this.y;
            }
            
            star.prototype.draw = function(){
                if(!expanse){
                    this.rotation = this.startRotation + (currentTime * this.speed);
                    if(!collapse){
                        if(this.y > this.yOrigin){
                            this.y-= 2.5;
                        }
                        if(this.y < this.yOrigin-4){
                            this.y+= (this.yOrigin - this.y) / 10;
                        }
                    } else {
                        this.trail = 1;
                        if(this.y > this.hoverPos){
                            this.y-= (this.hoverPos - this.y) / -5;
                        }
                        if(this.y < this.hoverPos-4){
                            this.y+= 2.5;
                        }
                    }
                } else {
                    this.rotation = this.startRotation + (currentTime * (this.speed / 2));
                    if(this.y > this.expansePos){
                        this.y-= Math.floor(this.expansePos - this.y) / -140;
                    }
                }

                context.save();
                context.fillStyle = this.color;
                context.strokeStyle = this.color;
                context.beginPath();
                var oldPos = rotate(centerx,centery,this.prevX,this.prevY,-this.prevR);
                context.moveTo(oldPos[0],oldPos[1]);
                context.translate(centerx, centery);
                context.rotate(this.rotation);
                context.translate(-centerx, -centery);
                context.lineTo(this.x,this.y);
                context.stroke();
                context.restore();

                this.prevR = this.rotation;
                this.prevX = this.x;
                this.prevY = this.y;
            }

            $(window).on('resize', function(){
                h = $(element).height();
                w = $(element).width();
                cw = w;
                ch = h;
                centerx = cw/2;
                centery = ch/2;
                
                canvas.attr({width: cw, height: ch});
                setDPI(canvas, 192);
                stars = [];
                
                context.fillStyle = 'rgba(25,25,25,1)';
                context.fillRect(0, 0, cw, ch);
                for(var i = 0; i < 2000; i++){
                    new star();
                }
            });

            window.requestFrame = (function(){
                return  window.requestAnimationFrame       ||
                    window.webkitRequestAnimationFrame ||
                    window.mozRequestAnimationFrame    ||
                    function( callback ){
                    window.setTimeout(callback, 1000 / 60);
                };
            })();

            function loop(){
                var now = new Date().getTime();
                currentTime = (now - startTime) / 50;

                context.fillStyle = 'rgba(25,25,25,0.2)';
                context.fillRect(0, 0, cw, ch);

                for(var i = 0; i < stars.length; i++){
                    if(stars[i] != stars){
                        stars[i].draw();
                    }
                }

                requestFrame(loop);
            }

            function init(){
                context.fillStyle = 'rgba(25,25,25,1)';
                context.fillRect(0, 0, cw, ch);
                for(var i = 0; i < 2000; i++){
                    new star();
                }
                loop();
            }
            
            init();
            
            $('.container').on('mouseover', function(){
                collapse = true;
            }).on('mouseout', function(){
                collapse = false;
            });
        }
        
    </script>
</body>
</html>
